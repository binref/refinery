"""
This module  exposes exceptions used by refinery.
"""
from __future__ import annotations

from typing import cast, Collection, Generic, Callable, TypeVar, TYPE_CHECKING

if TYPE_CHECKING:
    from refinery.units import Unit

_M = TypeVar('_M')


class RefineryImportMissing(ModuleNotFoundError):
    """
    A special variant of the `ModuleNotFoundError` exception which is raised when a dependency of a
    refinery unit is not installed in the current environment. The exception also provides hints
    about what package has to be installed in order to make that module available.
    """
    def __init__(self, missing: str, dependencies: Collection[str] = (), more: str | None = None):
        super().__init__()
        import shlex
        self.missing = missing
        self.install = ' '.join(shlex.quote(dist) for dist in dependencies)
        self.more = more
        self.dependencies = dependencies or (missing,)

    def __repr__(self):
        return F'{self.__class__.__name__}({self.missing!r})'


class MissingModule:
    """
    This class can wrap a module import that is currently missing. If any attribute of the missing
    module is accessed, it raises `refinery.units.RefineryImportMissing`.
    """
    def __init__(self, name, install=None, more=None):
        self.name = name
        self.install = install or [name]
        self.more = more

    def __getattr__(self, key: str):
        if key.startswith('__') and key.endswith('__'):
            raise AttributeError(key)
        raise RefineryImportMissing(self.name, self.install, more=self.more)


class LazyDependency(Generic[_M]):
    """
    A lazily evaluated dependency. Functions decorated with `refinery.lib.exceptions.dependency`
    are converted into this type. Calling the object returns either the return value of that
    function, which should be an imported module, or a `refinery.lib.exceptions.MissingModule`
    wrapper which will raise a `refinery.lib.exceptions.RefineryImportMissing` exception as soon
    as any of its members is accessed.
    """
    def __init__(self, imp: Callable[[], _M], name: str, dist: Collection[str], more: str | None):
        self.name = name
        self.dist = dist
        self.more = more
        self._imp = imp
        self.units: set[type[Unit]] = set()

    def register(self, unit: type[Unit] | None):
        if unit is None:
            return None
        if unit in (units := self.units):
            return unit
        if dist := self.dist:
            optmap = unit.optional_dependencies
            if optmap is None:
                unit.optional_dependencies = optmap = {}
            buckets = [optmap.setdefault(name, set()) for name in dist]
        else:
            bucket = unit.required_dependencies
            if bucket is None:
                unit.required_dependencies = bucket = set()
            buckets = [bucket]
        for bucket in buckets:
            bucket.add(self.name)
        units.add(unit)
        return unit

    def __call__(self) -> _M:
        try:
            return self._imp()
        except ImportError:
            install = {self.name}
            for unit in self.units:
                if deps := unit.optional_dependencies:
                    for v in deps.values():
                        install.update(v)
            return cast(_M, MissingModule(self.name, install=install, more=self.more))


def dependency(name: str, dist: Collection[str] = (), more: str | None = None):
    """
    A decorator to mark up an optional dependency. The decorated function can import the module
    and return the module object. The `name` argument of the decorator specifies the name of the
    dependency
    """
    def decorator(imp: Callable[[], _M]):
        return LazyDependency(imp, name, dist, more)
    return decorator


class RefineryCriticalException(RuntimeError):
    """
    If this exception is thrown, processing of the entire input stream
    is aborted instead of just aborting the processing of the current
    chunk.
    """
    pass


class RefineryPotentialUserError(RuntimeError):
    """
    This exception can be raised by a unit to inform the user about a
    suspected input error.
    """
    pass


class RefineryException(RuntimeError):
    """
    This is an exception that was not generated by an external library.
    """
    pass
